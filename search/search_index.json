{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to RCJ Soccer Sim! The RoboCupJunior Soccer Simulator is an attempt at playing RoboCupJunior Soccer in a virtualized environment. It is an experimental project organized by the RoboCupJunior Soccer Technical Committe. The simulator is based on Webots . The associated repository provides both the \"automatic referee\" (which implements the Soccer Simulated Rules ) as well as a sample team of robots with some basic simulated strategy. How do I try this out? Installation Install Python 3.7 (or higher) 64 bit from the official website (please make sure it is version 3.7 or higher for Windows, and 3.8 or higher if installing on MacOS or Linux). On Windows, please make sure your Python is referenced in Windows PATH by selecting the option \"Add Python 3.x to PATH\" during the installation. Check out this great installation guide if you need some help! Download Webots from their official website. Currently, version r2021a is stable with the Soccer Simulator. You can find detailed installation procedure on the official Webots Installation guide . Clone the rcj-soccer-sim repository to your computer by downloading the ZIP file from here or running git clone https://github.com/RoboCupJuniorTC/rcj-soccer-sim.git Finally, run Webots, go to Tools > Preferences > Python command and set it to python or python3 to point Webots to Python 3. Depending on your system, the reference to Python 3 can be via the command python or python3 . More information on how to configure Webots to work with Python can be found here . Running Soccer Sim Use Webots to open the downloaded soccer.wbt world located in the worlds directory (via File > Open World ) Run/pause the simulation by clicking the corresponding buttons on the top-part of Webots window. Note that the controllers that are responsible for the various robots on the field can be found in the controllers/ directory. Notes A specific webots world can be executed directly from the command line as follows: webots --mode=run worlds/soccer.wbt Which allows for at least some automation. Further info can be found in the docs . The sample players as well as the \"automatic referee\" are implemented in Python, which should allow for easily updating the code to match the rules and avoid any compilation issues.","title":"Welcome to RCJ Soccer Sim!"},{"location":"#welcome-to-rcj-soccer-sim","text":"The RoboCupJunior Soccer Simulator is an attempt at playing RoboCupJunior Soccer in a virtualized environment. It is an experimental project organized by the RoboCupJunior Soccer Technical Committe. The simulator is based on Webots . The associated repository provides both the \"automatic referee\" (which implements the Soccer Simulated Rules ) as well as a sample team of robots with some basic simulated strategy.","title":"Welcome to RCJ Soccer Sim!"},{"location":"#how-do-i-try-this-out","text":"","title":"How do I try this out?"},{"location":"#installation","text":"Install Python 3.7 (or higher) 64 bit from the official website (please make sure it is version 3.7 or higher for Windows, and 3.8 or higher if installing on MacOS or Linux). On Windows, please make sure your Python is referenced in Windows PATH by selecting the option \"Add Python 3.x to PATH\" during the installation. Check out this great installation guide if you need some help! Download Webots from their official website. Currently, version r2021a is stable with the Soccer Simulator. You can find detailed installation procedure on the official Webots Installation guide . Clone the rcj-soccer-sim repository to your computer by downloading the ZIP file from here or running git clone https://github.com/RoboCupJuniorTC/rcj-soccer-sim.git Finally, run Webots, go to Tools > Preferences > Python command and set it to python or python3 to point Webots to Python 3. Depending on your system, the reference to Python 3 can be via the command python or python3 . More information on how to configure Webots to work with Python can be found here .","title":"Installation"},{"location":"#running-soccer-sim","text":"Use Webots to open the downloaded soccer.wbt world located in the worlds directory (via File > Open World ) Run/pause the simulation by clicking the corresponding buttons on the top-part of Webots window. Note that the controllers that are responsible for the various robots on the field can be found in the controllers/ directory.","title":"Running Soccer Sim"},{"location":"#notes","text":"A specific webots world can be executed directly from the command line as follows: webots --mode=run worlds/soccer.wbt Which allows for at least some automation. Further info can be found in the docs . The sample players as well as the \"automatic referee\" are implemented in Python, which should allow for easily updating the code to match the rules and avoid any compilation issues.","title":"Notes"},{"location":"code_submission/","text":"Code submission To play the competition, the code that's powering the team's robots needs to get to the organizers. Let's talk a bit about how to do this. From controllers to a submission Suppose you have the folder structure which looks like this controllers/ \u251c\u2500\u2500 robot1/ \u2502 \u2514\u2500\u2500 robot1.py \u2502 \u2514\u2500\u2500 utils.py \u251c\u2500\u2500 robot2/ \u2502 \u2514\u2500\u2500 robot2.py \u2514\u2500\u2500 robot3/ \u2514\u2500\u2500 robot3.py To submit it for the competition, there are two (well, maybe three) things we need to do: 1. Add a team name 2. (Optionally) add a team logo 3. Create a ZIP archive Add a team name The folder structure above does contain some code but it is not immediately obvious which team does it belong to. To make it obvious, please create a file called team_name.txt on the same level as robot1/ , robot2/ and robot3/ . This file should contain a single line of text: the name of the team (up to 32 characters). The resulting folder structure would then look as follows: controllers/ \u251c\u2500\u2500 robot1/ \u2502 \u2514\u2500\u2500 robot1.py \u2502 \u2514\u2500\u2500 utils.py \u251c\u2500\u2500 robot2/ \u2502 \u2514\u2500\u2500 robot2.py \u251c\u2500\u2500 robot3/ \u2502 \u2514\u2500\u2500 robot3.py \u2514\u2500\u2500 team_name.txt (Optionally) add a team logo Note: This step is completely optional and you can just skip it -- your robot controllers will still work, even if you do not provide a custom logo for your team . If you'd like, you can optionally also add a custom logo for your team's robot. It will be used as an overlay on the robots in the simulator. The logo needs to be stored in the PNG format and located in a file called logo.png . If you choose to add one, the folder structure will looks something like the following: controllers/ \u251c\u2500\u2500 robot1/ \u2502 \u2514\u2500\u2500 robot1.py \u2502 \u2514\u2500\u2500 utils.py \u251c\u2500\u2500 robot2/ \u2502 \u2514\u2500\u2500 robot2.py \u251c\u2500\u2500 robot3/ \u2502 \u2514\u2500\u2500 robot3.py \u251c\u2500\u2500 logo.png \u2514\u2500\u2500 team_name.txt If you'd like to Create a ZIP archive This step is very simple: you just pick the three directories that contain the code for your three robots and the team_name.txt file and put them all together into a single .ZIP file. There are many utilities that will do the job -- we can recommend 7-Zip . When you look into the resulting .ZIP file, the folder structure should look as follows: . \u251c\u2500\u2500 robot1/ \u2502 \u2514\u2500\u2500 robot1.py \u2502 \u2514\u2500\u2500 utils.py \u251c\u2500\u2500 robot2/ \u2502 \u2514\u2500\u2500 robot2.py \u251c\u2500\u2500 robot3/ \u2502 \u2514\u2500\u2500 robot3.py \u251c\u2500\u2500 logo.png \u2514\u2500\u2500 team_name.txt Note that there is no controllers/ folder anymore -- the .ZIP file only contains three folders and a single text file called team_name.txt (and optionally logo.png ). Uploading your submission Once you have your .ZIP file ready, the only thing left is to submit it to the organizers. In practice, this generally means uploading it to a specific location that will be shared with all the participating teams well before the submission deadline. Things to keep in mind The resulting .ZIP file can be at most 10MB in size. The .ZIP file you submit needs to have exactly three first-level folders. That is, the folder structure after unzipping cannot look as follows: . \u251c\u2500\u2500 robot1 \u2502 \u2514\u2500\u2500 robot1.py \u251c\u2500\u2500 robot2 \u2502 \u2514\u2500\u2500 robot2.py \u251c\u2500\u2500 robot3 \u2502 \u2514\u2500\u2500 robot3.py \u2514\u2500\u2500 robot4 \u2514\u2500\u2500 robot4.py The tournament organization software would not know which three robots to pick up and would most likely end up picking them up randomly. The organizers will run a code similarity detector on the submitted code. Yes, wheels really do not need to be reinvented but it would really not be fair to win a competition with something that's not primarily the team's own work. Submissions with significant overlap of duplicated code will not be permitted to compete in the competition. The code you submit will be open sourced at the end of the competition. If you managed to find a bug, have any question or ran into some problem, please do not hesitate to ask on the forum .","title":"Code submission"},{"location":"code_submission/#code-submission","text":"To play the competition, the code that's powering the team's robots needs to get to the organizers. Let's talk a bit about how to do this.","title":"Code submission"},{"location":"code_submission/#from-controllers-to-a-submission","text":"Suppose you have the folder structure which looks like this controllers/ \u251c\u2500\u2500 robot1/ \u2502 \u2514\u2500\u2500 robot1.py \u2502 \u2514\u2500\u2500 utils.py \u251c\u2500\u2500 robot2/ \u2502 \u2514\u2500\u2500 robot2.py \u2514\u2500\u2500 robot3/ \u2514\u2500\u2500 robot3.py To submit it for the competition, there are two (well, maybe three) things we need to do: 1. Add a team name 2. (Optionally) add a team logo 3. Create a ZIP archive","title":"From controllers to a submission"},{"location":"code_submission/#add-a-team-name","text":"The folder structure above does contain some code but it is not immediately obvious which team does it belong to. To make it obvious, please create a file called team_name.txt on the same level as robot1/ , robot2/ and robot3/ . This file should contain a single line of text: the name of the team (up to 32 characters). The resulting folder structure would then look as follows: controllers/ \u251c\u2500\u2500 robot1/ \u2502 \u2514\u2500\u2500 robot1.py \u2502 \u2514\u2500\u2500 utils.py \u251c\u2500\u2500 robot2/ \u2502 \u2514\u2500\u2500 robot2.py \u251c\u2500\u2500 robot3/ \u2502 \u2514\u2500\u2500 robot3.py \u2514\u2500\u2500 team_name.txt","title":"Add a team name"},{"location":"code_submission/#optionally-add-a-team-logo","text":"Note: This step is completely optional and you can just skip it -- your robot controllers will still work, even if you do not provide a custom logo for your team . If you'd like, you can optionally also add a custom logo for your team's robot. It will be used as an overlay on the robots in the simulator. The logo needs to be stored in the PNG format and located in a file called logo.png . If you choose to add one, the folder structure will looks something like the following: controllers/ \u251c\u2500\u2500 robot1/ \u2502 \u2514\u2500\u2500 robot1.py \u2502 \u2514\u2500\u2500 utils.py \u251c\u2500\u2500 robot2/ \u2502 \u2514\u2500\u2500 robot2.py \u251c\u2500\u2500 robot3/ \u2502 \u2514\u2500\u2500 robot3.py \u251c\u2500\u2500 logo.png \u2514\u2500\u2500 team_name.txt If you'd like to","title":"(Optionally) add a team logo"},{"location":"code_submission/#create-a-zip-archive","text":"This step is very simple: you just pick the three directories that contain the code for your three robots and the team_name.txt file and put them all together into a single .ZIP file. There are many utilities that will do the job -- we can recommend 7-Zip . When you look into the resulting .ZIP file, the folder structure should look as follows: . \u251c\u2500\u2500 robot1/ \u2502 \u2514\u2500\u2500 robot1.py \u2502 \u2514\u2500\u2500 utils.py \u251c\u2500\u2500 robot2/ \u2502 \u2514\u2500\u2500 robot2.py \u251c\u2500\u2500 robot3/ \u2502 \u2514\u2500\u2500 robot3.py \u251c\u2500\u2500 logo.png \u2514\u2500\u2500 team_name.txt Note that there is no controllers/ folder anymore -- the .ZIP file only contains three folders and a single text file called team_name.txt (and optionally logo.png ).","title":"Create a ZIP archive"},{"location":"code_submission/#uploading-your-submission","text":"Once you have your .ZIP file ready, the only thing left is to submit it to the organizers. In practice, this generally means uploading it to a specific location that will be shared with all the participating teams well before the submission deadline.","title":"Uploading your submission"},{"location":"code_submission/#things-to-keep-in-mind","text":"The resulting .ZIP file can be at most 10MB in size. The .ZIP file you submit needs to have exactly three first-level folders. That is, the folder structure after unzipping cannot look as follows: . \u251c\u2500\u2500 robot1 \u2502 \u2514\u2500\u2500 robot1.py \u251c\u2500\u2500 robot2 \u2502 \u2514\u2500\u2500 robot2.py \u251c\u2500\u2500 robot3 \u2502 \u2514\u2500\u2500 robot3.py \u2514\u2500\u2500 robot4 \u2514\u2500\u2500 robot4.py The tournament organization software would not know which three robots to pick up and would most likely end up picking them up randomly. The organizers will run a code similarity detector on the submitted code. Yes, wheels really do not need to be reinvented but it would really not be fair to win a competition with something that's not primarily the team's own work. Submissions with significant overlap of duplicated code will not be permitted to compete in the competition. The code you submit will be open sourced at the end of the competition. If you managed to find a bug, have any question or ran into some problem, please do not hesitate to ask on the forum .","title":"Things to keep in mind"},{"location":"how_to/","text":"How to program your robot Controllers Each object in the simulation world can be controlled by a program. This program is called Controller . Each robot should have exactly one controller, implemented as a Python3 program. There is an invisible referee object in the simulation, which takes care of controlling the game and checking the rules. The controllers are located in the controllers directory. The name of the controller must be located in a subfolder with the same name (i.e. my_controller/my_controller.py ) and this name ought to be specified in soccer.wbt file. Hello world, robot! We have prepared a few sample robot controllers. They can be found in the controllers directory. Each controller is prefixed with rcj_soccer_player_ . They are all programmed in the same way, meaning they rotate to face the ball and then goes towards it. We decided to make the code reusable and put some common methods into the RCJSoccerRobot class inside rcj_soccer_robot.py file. Let's put together a simple program to showcase how you can go about programming a robot. from controller import Robot import struct TIME_STEP = 64 ROBOT_NAMES = [ \"B1\" , \"B2\" , \"B3\" , \"Y1\" , \"Y2\" , \"Y3\" ] N_ROBOTS = len ( ROBOT_NAMES ) class MyRobot : def __init__ ( self ): self . robot = Robot () self . name = self . robot . getName () self . receiver = self . robot . getDevice ( \"receiver\" ) self . receiver . enable ( TIME_STEP ) self . left_motor = self . robot . getDevice ( \"left wheel motor\" ) self . right_motor = self . robot . getDevice ( \"right wheel motor\" ) self . left_motor . setPosition ( float ( '+inf' )) self . right_motor . setPosition ( float ( '+inf' )) self . left_motor . setVelocity ( 0.0 ) self . right_motor . setVelocity ( 0.0 ) def get_new_data ( self ): packet = self . receiver . getData () self . receiver . nextPacket () struct_fmt = 'ddd' * 6 + 'dd' unpacked = struct . unpack ( struct_fmt , packet ) data = {} for i , r in enumerate ( ROBOT_NAMES ): data [ r ] = { \"x\" : unpacked [ 3 * i ], \"y\" : unpacked [ 3 * i + 1 ], \"orientation\" : unpacked [ 3 * i + 2 ] } data [ \"ball\" ] = { \"x\" : unpacked [ 3 * N_ROBOTS ], \"y\" : unpacked [ 3 * N_ROBOTS + 1 ] } return data def run ( self ): while self . robot . step ( TIME_STEP ) != - 1 : if self . receiver . getQueueLength () > 0 : data = self . get_new_data () # Get the position of our robot robot_pos = data [ self . name ] # Get the position of the ball ball_pos = data [ 'ball' ] self . left_motor . setVelocity ( 1 ) self . right_motor . setVelocity ( - 1 ) my_robot = MyRobot () my_robot . run () Let's explain the code in detail: from controller import Robot The Robot class is required to be imported because this is the only way we are able to controll the robot. The Robot class is shipped together with Webots. import struct This library is a built-in Python library , which is required to unpack the data sent by the supervisor. TIME_STEP = 64 ROBOT_NAMES = [ \"B1\" , \"B2\" , \"B3\" , \"Y1\" , \"Y2\" , \"Y3\" ] N_ROBOTS = len ( ROBOT_NAMES ) We also define some useful constants, whose values will be used later. class MyRobot : You can wrap the program into the class as we did. The benefit of OOP ( Object Oriented Programming ) is that you can later reuse the same common class throughout your controllers and therefore make the code easier to read. We are going to continue with our OOP approach. def __init__ ( self ): self . robot = Robot () self . name = self . robot . getName () ... The __init__ function is something like a constructor of the class and is called when an instance of the MyRobot object is created. We use this function to initialize some important variables. The most important one is the Robot instance, which allows us to get access to the so called Webots devices like motor (for controlling the speed) or receiver (for reading data from Supervisor). The name and the team of your robot can be determined by calling self.robot.getName() . It will give you one of {\"B1\", \"B2\", \"B3\", \"Y1\", \"Y2\", \"Y3\"} . The first letter determines the team (\"Blue\", \"Yellow\"), while the second one is the robot's identifier. def get_new_data ( self ): ... We are not going to explain this deeply. This function is to parse the incoming data from supervisor. Feel free to copy and use it. The resulting dictionary contains positions of all of the robots as well as the position of the ball. def run ( self ): This is the method which contains the logic for controlling the robot. while self . robot . step ( TIME_STEP ) != - 1 : The step function is crucial and must be used in every controller. This function synchronizes the sensor and actuator data between Webots and the controllers. if self . receiver . getQueueLength () > 0 : Before reading data, it is important to check if there is actually something in the queue that we can read. data = self . get_new_data () robot_pos = data [ self . name ] ball_pos = data [ 'ball' ] self . left_motor . setVelocity ( 1 ) self . right_motor . setVelocity ( - 1 ) And finally, after reading the new data received from supervisor, we do some calculations and set the speed of the motors. my_robot = MyRobot () my_robot . run () In the very end of our program, we initialize the robot and call the method run in order to execute the code. Importing shared code Each team consists of three robots. These robots might share some of the code and it is actually a good practice not to duplicate code all over the place. Imagine you have the folder structure which looks like this controllers/ \u251c\u2500\u2500 robot1/ \u2502 \u2514\u2500\u2500 robot1.py | \u2514\u2500\u2500 utils.py \u251c\u2500\u2500 robot2/ \u2502 \u2514\u2500\u2500 robot2.py \u251c\u2500\u2500 robot3/ \u2502 \u2514\u2500\u2500 robot3.py and within robot2.py you want to import some useful code from utils.py located in the robot1 folder. This is possible, but you need to put the following code snippet right at the top of your robot2.py file. import sys from pathlib import Path sys . path . append ( str ( Path ( '.' ) . absolute () . parent )) from robot1 import utils This will ensure that the code from robot1 is importable (it adds the parent folder to the Python PATH -- the list of folders where Python looks when importing modules). If you want to import utils within robot1 , you do no have to add these magic lines to robot1.py , but instead just call import utils because the PATH actually contains the folder of the script which is being run.","title":"How to program your robot"},{"location":"how_to/#how-to-program-your-robot","text":"","title":"How to program your robot"},{"location":"how_to/#controllers","text":"Each object in the simulation world can be controlled by a program. This program is called Controller . Each robot should have exactly one controller, implemented as a Python3 program. There is an invisible referee object in the simulation, which takes care of controlling the game and checking the rules. The controllers are located in the controllers directory. The name of the controller must be located in a subfolder with the same name (i.e. my_controller/my_controller.py ) and this name ought to be specified in soccer.wbt file.","title":"Controllers"},{"location":"how_to/#hello-world-robot","text":"We have prepared a few sample robot controllers. They can be found in the controllers directory. Each controller is prefixed with rcj_soccer_player_ . They are all programmed in the same way, meaning they rotate to face the ball and then goes towards it. We decided to make the code reusable and put some common methods into the RCJSoccerRobot class inside rcj_soccer_robot.py file. Let's put together a simple program to showcase how you can go about programming a robot. from controller import Robot import struct TIME_STEP = 64 ROBOT_NAMES = [ \"B1\" , \"B2\" , \"B3\" , \"Y1\" , \"Y2\" , \"Y3\" ] N_ROBOTS = len ( ROBOT_NAMES ) class MyRobot : def __init__ ( self ): self . robot = Robot () self . name = self . robot . getName () self . receiver = self . robot . getDevice ( \"receiver\" ) self . receiver . enable ( TIME_STEP ) self . left_motor = self . robot . getDevice ( \"left wheel motor\" ) self . right_motor = self . robot . getDevice ( \"right wheel motor\" ) self . left_motor . setPosition ( float ( '+inf' )) self . right_motor . setPosition ( float ( '+inf' )) self . left_motor . setVelocity ( 0.0 ) self . right_motor . setVelocity ( 0.0 ) def get_new_data ( self ): packet = self . receiver . getData () self . receiver . nextPacket () struct_fmt = 'ddd' * 6 + 'dd' unpacked = struct . unpack ( struct_fmt , packet ) data = {} for i , r in enumerate ( ROBOT_NAMES ): data [ r ] = { \"x\" : unpacked [ 3 * i ], \"y\" : unpacked [ 3 * i + 1 ], \"orientation\" : unpacked [ 3 * i + 2 ] } data [ \"ball\" ] = { \"x\" : unpacked [ 3 * N_ROBOTS ], \"y\" : unpacked [ 3 * N_ROBOTS + 1 ] } return data def run ( self ): while self . robot . step ( TIME_STEP ) != - 1 : if self . receiver . getQueueLength () > 0 : data = self . get_new_data () # Get the position of our robot robot_pos = data [ self . name ] # Get the position of the ball ball_pos = data [ 'ball' ] self . left_motor . setVelocity ( 1 ) self . right_motor . setVelocity ( - 1 ) my_robot = MyRobot () my_robot . run () Let's explain the code in detail: from controller import Robot The Robot class is required to be imported because this is the only way we are able to controll the robot. The Robot class is shipped together with Webots. import struct This library is a built-in Python library , which is required to unpack the data sent by the supervisor. TIME_STEP = 64 ROBOT_NAMES = [ \"B1\" , \"B2\" , \"B3\" , \"Y1\" , \"Y2\" , \"Y3\" ] N_ROBOTS = len ( ROBOT_NAMES ) We also define some useful constants, whose values will be used later. class MyRobot : You can wrap the program into the class as we did. The benefit of OOP ( Object Oriented Programming ) is that you can later reuse the same common class throughout your controllers and therefore make the code easier to read. We are going to continue with our OOP approach. def __init__ ( self ): self . robot = Robot () self . name = self . robot . getName () ... The __init__ function is something like a constructor of the class and is called when an instance of the MyRobot object is created. We use this function to initialize some important variables. The most important one is the Robot instance, which allows us to get access to the so called Webots devices like motor (for controlling the speed) or receiver (for reading data from Supervisor). The name and the team of your robot can be determined by calling self.robot.getName() . It will give you one of {\"B1\", \"B2\", \"B3\", \"Y1\", \"Y2\", \"Y3\"} . The first letter determines the team (\"Blue\", \"Yellow\"), while the second one is the robot's identifier. def get_new_data ( self ): ... We are not going to explain this deeply. This function is to parse the incoming data from supervisor. Feel free to copy and use it. The resulting dictionary contains positions of all of the robots as well as the position of the ball. def run ( self ): This is the method which contains the logic for controlling the robot. while self . robot . step ( TIME_STEP ) != - 1 : The step function is crucial and must be used in every controller. This function synchronizes the sensor and actuator data between Webots and the controllers. if self . receiver . getQueueLength () > 0 : Before reading data, it is important to check if there is actually something in the queue that we can read. data = self . get_new_data () robot_pos = data [ self . name ] ball_pos = data [ 'ball' ] self . left_motor . setVelocity ( 1 ) self . right_motor . setVelocity ( - 1 ) And finally, after reading the new data received from supervisor, we do some calculations and set the speed of the motors. my_robot = MyRobot () my_robot . run () In the very end of our program, we initialize the robot and call the method run in order to execute the code.","title":"Hello world, robot!"},{"location":"how_to/#importing-shared-code","text":"Each team consists of three robots. These robots might share some of the code and it is actually a good practice not to duplicate code all over the place. Imagine you have the folder structure which looks like this controllers/ \u251c\u2500\u2500 robot1/ \u2502 \u2514\u2500\u2500 robot1.py | \u2514\u2500\u2500 utils.py \u251c\u2500\u2500 robot2/ \u2502 \u2514\u2500\u2500 robot2.py \u251c\u2500\u2500 robot3/ \u2502 \u2514\u2500\u2500 robot3.py and within robot2.py you want to import some useful code from utils.py located in the robot1 folder. This is possible, but you need to put the following code snippet right at the top of your robot2.py file. import sys from pathlib import Path sys . path . append ( str ( Path ( '.' ) . absolute () . parent )) from robot1 import utils This will ensure that the code from robot1 is importable (it adds the parent folder to the Python PATH -- the list of folders where Python looks when importing modules). If you want to import utils within robot1 , you do no have to add these magic lines to robot1.py , but instead just call import utils because the PATH actually contains the folder of the script which is being run.","title":"Importing shared code"}]}